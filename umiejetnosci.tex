\section{Umiejętności Bohaterów}
Zgodnie z naszymi założeniami każdy bohater miał być unikalny i odgrywać ważną rolę w całej rozgrywce. Wszystkich nadaliśmy różne umiejętności, a każda z nich jest niezbędna, by wspólnie ukończyć grę.

\subsection{Wojownik}

Wojownik słynie z ogromnej siły, jego zadaniem jest rozprawianie się z jak największą ilością przeciwników. Do jego postaci napisaliśmy skrypt, który pobiera listę obiektów znajdujących się w jego obrębie a następnie każdemu z nich odbiera życie. Skrypty dodawane są do postaci na podobnej zasadzie, jak \name{Komponenty}. W jednej z klatek animacji uderzenia mieczem ustawiliśmy tzw. \name{Trigger}, który uruchamia odpowiednie zdarzenie. Każda z postaci znajdujących się na planszy posiada specjalny \name{Tag}, jest to dodatkowa informacja o obiekcie w postaci ciągu znaków, w wypadku wroga jest to \textit{Enemy}. Siła rażenia zależna jest od rodzaju ataku (Wojownik posiada 2 rodzaje ataku - standardowy szybki oraz silny, który jednak trwa nieco dłużej).
\\
\begin{lstlisting}[caption={Algorytm zadawania obrażeń wrogom}]
// HitEvent is animation triggered method
void HitEvent(int type)
{
    if (!photonView.isMine) return;

    Collider[] hitColliders = Physics.OverlapSphere(transform.position, attackDistance);
    foreach (var enemyCollider in hitColliders)
    {
        if (enemyCollider.tag == "Enemy")
        {
            float damageValue = 0.0f;
            switch (type)
            {
                case 0: damageValue = 20.0f; break;
                case 1: damageValue = 50.0f; break;
            }
            enemyCollider.gameObject.GetPhotonView().RPC("damage", PhotonTargets.All, damageValue);
        }
    }
}
\end{lstlisting}


\subsection{Mag}

Mag posiada umiejętność podnoszenia przedmiotów, którą możemy wykorzystać na dwa sposoby. Jednym z nich jest pokonywanie przeszkód, drugim atak. Specjalny skrypt umieszczony w komponentach wykorzystuje celownik, za którym podąża kamera. Gdy najedziemy celownikiem na obiekt o odpowiednim oznaczeniu, możemy go podnieść. Gracz może obracać przedmiot wokół własnej osi, oddalać go od siebie i przybliżać. Przy pomocy odpowiedniego przycisku może również rzucić trzymanym przedmiotem w przeciwnika. Dzięki wykorzystaniu grawitacji i kolizji z danymi przedmiotami możemy w ten sposób zabrać życie naszym przeciwnikom.

Aby odnaleźć interesujący nas obiekt, tworzymy wiązkę (\textit{Ray}), przechodzącą z pozycji kamery przez środek ekranu, gdzie znajduje się celownik, a następnie pobieramy listę wszystkich obiektów, które ta wiązka przecina, przy zadanej maksymalnej odległości. Następnie iterujemy poprzez wszystkie znalezione obiekty, i gdy znajdziemy obiekt posiadający tag \textit{Holdable}, wyłączamy grawitację tego obiektu, wyliczamy odległość od niego, a następnie pobieramy jego wskaźnik do zmiennej globalnej, w celu możliwości manipulowania tym obiektem:
\\
\begin{lstlisting}[caption={Algorytm wykrywania obiektów w obrębie Maga, które mogą zostać przeniesione}]
ray = Camera.main.ScreenPointToRay(new Vector3(Screen.width / 2, Screen.height / 2));
hits = Physics.RaycastAll(ray);
foreach (var hit in hits)
{
    if (hit.transform.gameObject.tag == "Holdable" && hit.distance < objectDistanceMax)
    {
        turnSpecialCrosshair(true);

        if (Input.GetMouseButtonDown(0) && holdedThing == null)
        {
            holdedThing = hit.transform.gameObject;
            objectDistance = Mathf.Clamp(hit.distance, colliderSize(holdedThing) / 2 + objectDistanceMin, objectDistanceMax);
            holdedThing.GetComponent<PhotonView> ().RequestOwnership ();
            photonView.RPC("setGravity", PhotonTargets.All, hit.transform.gameObject.GetComponent<PhotonView>().viewID, false);
            break;
        }
    } else
    {
        turnSpecialCrosshair(false);
    }
}
\end{lstlisting}

Po wykryciu obiektu, który da się przenieść, zmienia się również kolor wskaźnika (na zasadzie podmiany grafiki celownika). Nie wdrażając się we wszystkie szczegóły (oddalanie, przybliżanie, rzucanie - są to kolejne manipulacje obiektem), fragment kodu przemieszczania obiektów wylicza punkt w przestrzeni 3D oddalony o odpowiednią wartość od widoku kamery, a następnie na tej podstawie wylicza trójwymiarowy wektor prędkości, dzięki czemu przenoszony obiekt dąży w każdej z osi do docelowego punktu:
\\
\begin{lstlisting}[caption={Algorytm przenoszenia obiektów}]
// Moving object in space
if (holdedThing != null)
{
    // Get point in front of camera
    var newObjectPosition = ray.GetPoint(objectDistance);

    // Move holded thing to new destination in front of camera
    var holdedThingDestination = Vector3.ClampMagnitude((newObjectPosition - holdedThing.transform.position) * objectMoveSpeed, objectMoveSpeed);
    holdedThing.GetComponent<Rigidbody>().velocity = holdedThingDestination;
...
\end{lstlisting}

Wartość prędkości podążania obiektu za punktem docelowym jest ustawiona z góry i dopasowana tak, aby przenoszony obiekt sprawiał wrażenie delikatnej bezwładności.


Łotr jest przebiegły, potrafi pozyskiwać informacje oraz dostrzega znacznie więcej niż inni. Posiada skrypt, który umożliwia mu rozmowę z innymi osobami, która udzielają mu cennych informacji, gdy tylko znajdzie się w odpowiedniej odległości. Może też wyszukiwać przedmioty, które pozostają niewidoczne dla pozostałych graczy.
